//ALL REQUEST PROTOS SHOULD INCLUDE A MinimumUserProto AS REQUIRED that represents which client sent it/triggered it 

import "Info.proto";

package com.lvl6.proto;

option java_outer_classname = "EventProto";

//------------------------------------------------------------------------------------------

																						//DONE
message ChatRequestProto {
    required MinimumUserProto sender = 1; 
	repeated MinimumUserProto recipients = 2;
	required string message = 3;
}

																						//DONE
message ChatResponseProto {
    required MinimumUserProto sender = 1; 
	required string message = 2;
}

//------------------------------------------------------------------------------------------

																						//DONE
message BattleRequestProto {
    required MinimumUserProto attacker = 1; 
    required MinimumUserProto defender = 2; 
    required BattleResult battleResult = 3;
    required int64 clientTime = 4;
    optional int32 neutralCityId = 5;
    repeated FullUserEquipProto defenderUserEquips = 6;
}

																						//DONE
message BattleResponseProto {
    required MinimumUserProto attacker = 1;
    required MinimumUserProto defender = 2;
	required BattleStatus status = 3;

	optional int32 coinsGained = 4;
	optional FullEquipProto equipGained = 5;
    optional int32 expGained = 6;
    
    enum BattleStatus {
		SUCCESS = 0;
		OTHER_FAIL = 1;
	} 
}

//------------------------------------------------------------------------------------------

																						//DONE
message VaultRequestProto {
	required MinimumUserProto sender = 1;
	optional VaultRequestType requestType = 2;
	optional int32 amount = 3;
	enum VaultRequestType {
		DEPOSIT = 0; 
		WITHDRAW = 1;
	} 
	
}

																						//DONE
message VaultResponseProto {
	required MinimumUserProto sender = 1;
	required VaultStatus status = 2;	
	optional int32 vaultAmount = 3;
	optional int32 coinAmount = 4;
	
	enum VaultStatus {
		SUCCESS = 0;
		LEVEL_TOO_LOW = 1;
		OTHER_FAIL = 2;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message ArmoryRequestProto {
   enum ArmoryRequestType {
		BUY = 0; 
		SELL = 1;
	} 
	required MinimumUserProto sender = 1;
	required ArmoryRequestType requestType = 2;
	required int32 quantity = 3;
	required int32 equipId = 4;	
}

																						//DONE
message ArmoryResponseProto {
	required MinimumUserProto sender = 1;
	required ArmoryStatus status = 2;
	
	enum ArmoryStatus {
		SUCCESS = 0; 
		NOT_ENOUGH_EQUIP_TO_SELL = 1;
		NOT_ENOUGH_CURRENCY_TO_BUY = 2;
		CANNOT_SELL_DIAMOND_EQUIP = 3;
		LEVEL_TOO_LOW = 4;
		OTHER_FAIL = 5;
	} 
}

//------------------------------------------------------------------------------------------

message StartupRequestProto {				//client will also send ChangeUserLocationRequestProto
     required string udid = 1;
     required float versionNum = 2;			//1.0->2.0 critical, 1.0->1.1 minor. server checks db for latest vnum
     optional string deviceToken = 4;		//only set this if the client is registered/has a device token
}

message StartupResponseProto {
    optional FullUserProto sender = 1;
    required StartupStatus startupStatus= 2;
    required UpdateStatus updateStatus= 3;
    required StartupConstants startupConstants = 4;
    optional TutorialConstants tutorialConstants = 18;
    repeated FullCityProto citiesAvailableToUser = 5;
    repeated FullUserCityProto userCityInfos = 16;
    
    repeated FullQuestProto inProgressQuests = 6;
	repeated FullQuestProto availableQuests = 7;   
	repeated FullUserEquipProto userEquips = 8;
    repeated FullEquipProto equips = 9;
	optional int32 experienceRequiredForNextLevel = 10;
	optional int32 experienceRequiredForCurrentLevel = 15;
	
	repeated MarketplacePostPurchasedNotificationProto marketplacePurchaseNotifications = 12;
	repeated AttackedNotificationProto attackNotifications = 13;
	repeated ReferralNotificationProto referralNotifications = 14;
	
	message MarketplacePostPurchasedNotificationProto {
		required FullMarketplacePostProto marketplacePost = 1;
		required MinimumUserProto buyer = 2;
		required int64 timeOfPurchase = 3;
	}

	message AttackedNotificationProto {
		required MinimumUserProto attacker = 1;
		required BattleResult battleResult = 2;
		required int64 battleCompleteTime = 3;
		optional int32 coinsStolen = 4;
		optional int32 stolenEquipId = 5;
	}
	
	message ReferralNotificationProto {
		required MinimumUserProto referred = 1;
		required int64 recruitTime = 2;
	}
	  
	message StartupConstants {
	  	repeated string productIds = 1;
	  	repeated int32 productDiamondsGiven = 2;
    	required int32 maxLevelDifferenceForBattle = 6;
    	
    	required int32 armoryXLength = 7;
    	required int32 armoryYLength = 8;
    	required int32 vaultXLength = 9;
    	required int32 vaultYLength = 10;
    	required int32 marketplaceXLength = 11;
    	required int32 marketplaceYLength = 12;
    	required int32 carpenterXLength = 13;
    	required int32 carpenterYLength = 14;
    	required int32 aviaryXLength = 15;
    	required int32 aviaryYLength = 16;    	

		required int32 attackBaseGain = 17;
		required int32 defenseBaseGain = 18;
		required int32 energyBaseGain = 19;
		required int32 healthBaseGain = 20;
		required int32 staminaBaseGain = 21;
		required int32 attackBaseCost = 22;
		required int32 defenseBaseCost = 23;
		required int32 energyBaseCost = 24;
		required int32 healthBaseCost = 25;
		required int32 staminaBaseCost = 26;
		
		required int32 skillPointsGainedOnLevelup = 27;
		required int32 cutOfVaultDepositTaken = 28;
		
		required int32 maxLevelForStruct = 33;
		required int32 maxNumOfSingleStruct = 34;
		required double percentReturnedToUserForSellingNormStructure = 35;
		
		required int32 minutesToRefillAEnergy = 36;
		required int32 minutesToRefillAStamina = 37;
		
		required int32 diamondCostForFullStaminaRefill = 48;
		required int32 diamondCostForFullEnergyRefill = 49;
		
		required int32 maxNumberOfMarketplacePosts = 40;
		required double percentOfSellingCostTakenFromSellerOnMarketplacePurchase = 41;
   		required double percentOfSellingCostTakenFromSellerOnMarketplaceRetract = 42;
		required int32 numDaysLongMarketplaceLicenseLastsFor = 43;
		required int32 numDaysShortMarketplaceLicenseLastsFor = 44;
		required int32 diamondCostOfLongMarketplaceLicense = 45;
		required int32 diamondCostOfShortMarketplaceLicense = 46;

		required int32 maxNumbersOfEnemiesToGenerateAtOnce = 4;
		required double percentReturnedToUserForSellingEquipInArmory = 5;
		    	   	
		//ADD a bunch of other important constants
	}
	
	message TutorialConstants {
		required int32 initEnergy = 1;
		required int32 initStamina = 2;
		required int32 initHealth = 3;
		required FullTutorialQuestProto tutorialQuest = 4;
		required int32 structToBuild = 5;
		required int32 diamondCostToInstabuildFirstStruct = 6;

		required int32 archerInitAttack = 17;
		required int32 archerInitDefense = 18;
		required FullEquipProto archerInitWeapon = 7;
		required FullEquipProto archerInitArmor = 8;
		
		required int32 mageInitAttack = 9;
		required int32 mageInitDefense = 10;
		required FullEquipProto mageInitWeapon = 11;
		required FullEquipProto mageInitArmor = 12;
		
		required int32 warriorInitAttack = 13;
		required int32 warriorInitDefense = 14;
		required FullEquipProto warriorInitWeapon = 15;
		required FullEquipProto warriorInitArmor = 16;
		
		required int32 minNameLength = 19;
		required int32 maxNameLength = 20;
		required int32 diamondRewardForReferrer = 21;
		required int32 diamondRewardForBeingReferred = 22;		

		message FullTutorialQuestProto {
				//do one task once, kill one enemy
			required string goodName = 1;
			required string badName = 2;
			required string goodDescription = 3;
			required string badDescription = 4;
			required string goodDoneResponse = 5;
			required string badDoneResponse = 6;
			required string goodInProgress = 7;
			required string badInProgress = 8;
			required int32 assetNumWithinCity = 9; 
			required int32 coinsGained = 10;
			required int32 expGained = 11;
			
			required FullTaskProto firstTaskGood = 12;
			required FullTaskProto firstTaskBad = 13;
			required int32 firstTaskCompleteCoinGain = 14;	//tasks coin gain should sum to this

			required int32 firstDefeatTypeJobBattleCoinGain = 17;
			required int32 firstDefeatTypeJobBattleExpGain = 18;
			required FullEquipProto firstDefeatTypeJobBattleLootAmulet = 19;
		}
	}
		     
    enum UpdateStatus {
     	NO_UPDATE = 0;
     	MINOR_UPDATE = 1;			//NOTIFY USER OF NEW FEATURES AND/OR ASK USER IF HE WANTS TO UPDATE NOW
     	MAJOR_UPDATE = 2;			//NOT ALLOWED TO PLAY
     }
     
	enum StartupStatus {
		USER_IN_DB = 0; 
		USER_NOT_IN_DB = 1;
	}    
}

//------------------------------------------------------------------------------------------
//CALL STARTUP AFTER THIS

//if devicetoken doesnt work, itll still return success
//client can check user's diamonds to see if it went through
message UserCreateRequestProto {
     required string udid = 1;
     required string name = 2;
     required UserType type = 3;
     optional LocationProto userLocation = 6;     
     optional string referrerCode = 7;
     optional string deviceToken = 8;
     required int32 attack = 9;
     required int32 defense = 10;
     required int32 health = 11;
     required int32 energy = 12;
     required int32 stamina = 13;
     
     required int64 timeOfStructPurchase = 14;
     required int64 timeOfStructBuild = 15;
     required CoordinateProto structCoords = 4;
     required bool usedDiamondsToBuilt = 16;
}

message UserCreateResponseProto {
	optional FullUserProto sender = 1;
	required UserCreateStatus status = 2;
	
    enum UserCreateStatus {
		SUCCESS = 0;
		INVALID_NAME = 1;
		INVALID_LOCATION = 2;
		USER_WITH_UDID_ALREADY_EXISTS = 3;
     	CLIENT_TOO_AHEAD_OF_SERVER_TIME = 4;
		OTHER_FAIL = 4;
	}  
}

//------------------------------------------------------------------------------------------

																						//DONE
message RetrieveTasksForCityRequestProto {
     required MinimumUserProto sender = 1;
     optional int32 cityId = 2;
}

																						//DONE
message RetrieveTasksForCityResponseProto {
     required MinimumUserProto sender = 1;
     repeated FullTaskProto tasks = 2;
}

//------------------------------------------------------------------------------------------

																						//DONE
message RetrieveStaticDataForShopRequestProto {
     required MinimumUserProto sender = 1;
	required RetrieveForShopType type = 2;
		
	enum RetrieveForShopType {
		EQUIPMENT_FOR_ARMORY = 0;
		ALL_STRUCTURES = 1;
	}
}
																						//DONE
message RetrieveStaticDataForShopResponseProto {
     required MinimumUserProto sender = 1;
     required RetrieveStaticDataForShopStatus status = 2;
     repeated FullEquipProto equips = 3;
     repeated FullStructureProto structs = 4;
     
     enum RetrieveStaticDataForShopStatus {
     	SUCCESS = 0;
     	SOME_FAIL = 1;
     }
}

//------------------------------------------------------------------------------------------

																						//DONE
message TaskActionRequestProto {
	required MinimumUserProto sender = 1;
	required int32 taskId = 2;
	required int64 curTime = 3;
}

																						//DONE
message TaskActionResponseProto {
	required MinimumUserProto sender = 1;
	required TaskActionStatus status = 2;
	optional bool taskCompleted = 3;
	optional bool cityRankedUp = 4;
	optional int32 lootEquipId = 5;
	optional int32 coinsGained = 6;
	
	optional int32 coinBonusIfCityRankup = 7;
	optional int32 expBonusIfCityRankup = 8;
	
	enum TaskActionStatus {
		SUCCESS = 0; 
		USER_NOT_ENOUGH_ENERGY = 1;
		USER_NOT_ALL_REQUIRED_ITEMS = 2;
		OTHER_FAIL = 3;
		CLIENT_TOO_AHEAD_OF_SERVER_TIME = 4;
	} 
}

//------------------------------------------------------------------------------------------

																						//DONE
message PurchaseNormStructureRequestProto {
	required MinimumUserProto sender = 1;
	required CoordinateProto structCoordinates = 2;
	required int32 structId = 3;
	required int64 timeOfPurchase = 4;
}

																						//DONE
message PurchaseNormStructureResponseProto {
	required MinimumUserProto sender = 1;
	required PurchaseNormStructureStatus status = 2;
	optional int32 userStructId = 3;
	
	enum PurchaseNormStructureStatus {
		SUCCESS = 0;
		NOT_ENOUGH_MATERIALS = 1;
		LEVEL_TOO_LOW = 2;
		ANOTHER_STRUCT_STILL_BUILDING = 3;
		ALREADY_HAVE_MAX_OF_THIS_STRUCT = 4;
		OTHER_FAIL = 5;
		CLIENT_TOO_AHEAD_OF_SERVER_TIME = 6;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message MoveOrRotateNormStructureRequestProto {
	required MinimumUserProto sender = 1;
	required int32 userStructId = 2;
	required MoveOrRotateNormStructType type = 3;
	optional CoordinateProto curStructCoordinates = 4;
	optional StructOrientation newOrientation = 5;
	
	enum MoveOrRotateNormStructType {
		MOVE = 0;
		ROTATE = 1;
	}
}

																						//DONE
message MoveOrRotateNormStructureResponseProto {
	required MinimumUserProto sender = 1;
	required MoveOrRotateNormStructureStatus status = 2;
	
	enum MoveOrRotateNormStructureStatus {
		SUCCESS = 0;
		OTHER_FAIL = 2;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message SellNormStructureRequestProto {
	required MinimumUserProto sender = 1;
	required int32 userStructId = 2;
}

																						//DONE
message SellNormStructureResponseProto {
	required MinimumUserProto sender = 1;
	required SellNormStructureStatus status = 2;
	
	enum SellNormStructureStatus {
		SUCCESS = 0;
		FAIL = 1;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message UpgradeNormStructureRequestProto {
	required MinimumUserProto sender = 1;
	required int32 userStructId = 2;
	required int64 timeOfUpgrade = 3;	
}

																						//DONE
message UpgradeNormStructureResponseProto {
	required MinimumUserProto sender = 1;
	required UpgradeNormStructureStatus status = 2;
	
	enum UpgradeNormStructureStatus {
		SUCCESS = 0;
		NOT_ENOUGH_MATERIALS = 1;
		NOT_BUILT_YET = 2;
		NOT_USERS_STRUCT = 3;
		ANOTHER_STRUCT_STILL_UPGRADING = 4;
		OTHER_FAIL = 5;
		CLIENT_TOO_AHEAD_OF_SERVER_TIME = 6;
		AT_MAX_LEVEL_ALREADY = 7;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message RetrieveCurrencyFromNormStructureRequestProto {
	required MinimumUserProto sender = 1;
	required int32 userStructId = 2;
	required int64 timeOfRetrieval = 3;	
}

																						//DONE
message RetrieveCurrencyFromNormStructureResponseProto {
	required MinimumUserProto sender = 1;
	required RetrieveCurrencyFromNormStructureStatus status = 2;
	
	enum RetrieveCurrencyFromNormStructureStatus {
		SUCCESS = 0;
		NOT_LONG_ENOUGH = 1;
		OTHER_FAIL = 2;
		CLIENT_TOO_AHEAD_OF_SERVER_TIME = 3;
		LEVEL_TOO_LOW = 4;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message CriticalStructureActionRequestProto {
	required MinimumUserProto sender = 1;
	required CritStructActionType actionType = 2;
	required CritStructType critStructType = 3;
	optional CoordinateProto critStructCoordinates = 4;
	optional StructOrientation orientation = 5;
	
	enum CritStructActionType {
		PLACE = 0;
		MOVE = 1;
		ROTATE = 2;
	}
}

																						//DONE
message CriticalStructureActionResponseProto {
	required MinimumUserProto sender = 1;
	required CritStructActionStatus status = 3;
	
	enum CritStructActionStatus {
		SUCCESS = 0;
		CANNOT_PLACE_NON_PLACEABLE_CRIT_STRUCT = 1;	//we only place armory/vault/marketplace 
		NOT_ACCESSIBLE_TO_USERS_LEVEL = 2;
		CANNOT_MOVE_AVIARY = 3;
		OTHER_FAIL = 4;	
	}
}

//------------------------------------------------------------------------------------------

//done for both finishing a struct's building and instantly gettin income
																						//DONE
message FinishNormStructWaittimeWithDiamondsRequestProto {
	required MinimumUserProto sender = 1;
	required int32 userStructId = 2;
	required int64 timeOfPurchase = 3;			//lastRetrieved will start with this date
	required NormStructWaitTimeType waitTimeType = 4;

	enum NormStructWaitTimeType {
		FINISH_CONSTRUCTION = 0;
		FINISH_INCOME_WAITTIME = 1;
		FINISH_UPGRADE = 2;
	}
}

																						//DONE
message FinishNormStructWaittimeWithDiamondsResponseProto {
     required MinimumUserProto sender = 1;
     required FinishNormStructWaittimeStatus status = 2;
     
     enum FinishNormStructWaittimeStatus {
     	SUCCESS = 0;
     	NOT_ENOUGH_DIAMONDS = 1;
     	OTHER_FAIL = 2;
     	CLIENT_TOO_AHEAD_OF_SERVER_TIME = 3;
     }
}

//------------------------------------------------------------------------------------------

//this message sent to server after a player's homepage is loaded and client checks which structs 
//have been built but not reflected in db yet (so when is_complete=0 but the purchase_time 
//implies that it should be)
//this message is also sent whenever the player is on the screen and the build completes
//i would set last_retrieved manually to when it should have completed, and is_complete=1
											
																						//DONE
//NOT VERY EFFICIENT..extra db call. and for every newly built building, new db call. but w/e for now.																						
message NormStructWaitCompleteRequestProto {
	required MinimumUserProto sender = 1;
	repeated int32 userStructId = 2;
	required int64 curTime = 3;						//used for checking
}

																						//DONE
message NormStructWaitCompleteResponseProto {
     required MinimumUserProto sender = 1;
     required NormStructWaitCompleteStatus status = 2;
     repeated FullUserStructureProto userStruct = 3;
     
     enum NormStructWaitCompleteStatus {
     	SUCCESS = 0;
     	NOT_DONE_YET = 1;
     	OTHER_FAIL = 2;
     	CLIENT_TOO_AHEAD_OF_SERVER_TIME = 3;
     }
}

//------------------------------------------------------------------------------------------

//client calls this whenever exp surpasses the next one
//server checks if user's exp is over the next, if so, increments user's level
																						//DONE

message LevelUpRequestProto {
	required MinimumUserProto sender = 1;
}

																						//DONE
message LevelUpResponseProto {
     required MinimumUserProto sender = 1;
     required LevelUpStatus status = 2;
     
     optional int32 newLevel = 11;
     optional int32 newNextLevel = 3;
     optional int32 experienceRequiredForNewNextLevel = 4;
	 repeated FullCityProto citiesNewlyAvailableToUser = 5;					//only new ones
     repeated FullEquipProto newlyEquippableEpicsAndLegendaries = 6;			//only new ones
     repeated FullStructureProto newlyAvailableStructs = 7;					//only new ones
     optional bool marketplaceUnlocked = 8;
     optional bool vaultUnlocked = 9;
     optional bool armoryUnlocked = 10;
     
	enum LevelUpStatus {
     	SUCCESS = 0;
     	NOT_ENOUGH_EXP_TO_NEXT_LEVEL = 1;
     	ALREADY_AT_MAX_LEVEL = 2;
     	OTHER_FAIL = 3;
     }
}

//------------------------------------------------------------------------------------------

																						//DONE
message InAppPurchaseRequestProto {
	required MinimumUserProto sender = 1;
	required string receipt = 2;
}

																						//DONE
message InAppPurchaseResponseProto {
	required MinimumUserProto sender = 1;
	required InAppPurchaseStatus status = 2;
	optional int32 diamondsGained = 3;
	
	enum InAppPurchaseStatus {
		SUCCESS = 0;
		FAIL = 1;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message UpdateClientUserResponseProto {
     required FullUserProto sender = 1;
     required int64 timeOfUserUpdate = 2;				//new Date().getTime(); milliseconds since 1/1/70
}

//------------------------------------------------------------------------------------------

message RetrieveCurrentMarketplacePostsRequestProto {
	required MinimumUserProto sender = 1;
	optional int32 beforeThisPostId = 2;
	required bool fromSender = 3;
}

																						//DONE
message RetrieveCurrentMarketplacePostsResponseProto {
     required MinimumUserProto sender = 1;
     required bool fromSender = 2;
     optional int32 beforeThisPostId = 3;
	 required RetrieveCurrentMarketplacePostsStatus status = 4;
     
     repeated FullMarketplacePostProto marketplacePosts = 5;
     
     enum RetrieveCurrentMarketplacePostsStatus {
     	SUCCESS = 0;
     	LEVEL_TOO_LOW = 1;
     	OTHER_FAIL = 2;
     }
}

//------------------------------------------------------------------------------------------

																						//DONE
message PostToMarketplaceRequestProto {
	required MinimumUserProto sender = 1;
	required int32 postedEquipId = 2;
	optional int32 diamondCost = 3;
	optional int32 coinCost = 4;
}

																						//DONE
message PostToMarketplaceResponseProto {
     required MinimumUserProto sender = 1;
     required PostToMarketplaceStatus status = 2;
    
    enum PostToMarketplaceStatus {
		SUCCESS = 0;
		NEGATIVE_POST = 1;
		NOT_ENOUGH_EQUIP = 2;
		NEGATIVE_COST = 3;
		NO_COST = 4;
		USER_ALREADY_MAX_MARKETPLACE_POSTS = 5;
		CANT_DEMAND_BOTH = 6;
		INVALID_COST_TYPE_FOR_POST = 7;
		NO_LICENSE = 8;
		LEVEL_TOO_LOW = 9;
		OTHER_FAIL = 10;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message RetractMarketplacePostRequestProto {
	required MinimumUserProto sender = 1;
	required int32 marketplacePostId = 2;
}

																						//DONE
message RetractMarketplacePostResponseProto {
     required MinimumUserProto sender = 1;
     required RetractMarketplacePostStatus status = 2;

	enum RetractMarketplacePostStatus {
		SUCCESS = 0;
		NOT_REQUESTERS_POST = 1;
		POST_NO_LONGER_EXISTS = 2;
		NOT_ENOUGH_DIAMONDS = 3;
		NOT_ENOUGH_COINS = 4;
		LEVEL_TOO_LOW = 5;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message PurchaseFromMarketplaceRequestProto {
	required MinimumUserProto sender = 1;
	required int32 marketplacePostId = 2;
	required int32 posterId = 3;
}

																						//DONE
message PurchaseFromMarketplaceResponseProto {
     required MinimumUserProto purchaser = 1;
     required int32 posterId = 2;
     
     required PurchaseFromMarketplaceStatus status = 3;

	enum PurchaseFromMarketplaceStatus {
		SUCCESS = 0;
		NOT_ENOUGH_MATERIALS = 1;
		POST_NO_LONGER_EXISTS = 2;
		PURCHASER_IS_SELLER = 3;
		LEVEL_TOO_LOW = 4;
		OTHER_FAIL = 5;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message UseSkillPointRequestProto {
	required MinimumUserProto sender = 1;
	required BoostType boostType = 2;
	
	enum BoostType {
		ATTACK = 0;
		DEFENSE = 1;
		ENERGY = 2;
		HEALTH = 3;
		STAMINA = 4;
	}
}

																						//DONE
message UseSkillPointResponseProto {
     required MinimumUserProto sender = 1;
     required UseSkillPointStatus status = 2;
     
     enum UseSkillPointStatus {
		SUCCESS = 0;
		NOT_ENOUGH_SKILL_POINTS = 1;
		OTHER_FAIL = 2;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message GenerateAttackListRequestProto {
	required MinimumUserProto sender = 1;
	required int32 numEnemies = 2;
	optional int32 latLowerBound = 3;
	optional int32 latUpperBound = 4;
	optional int32 longLowerBound = 5;
	optional int32 longUpperBound = 6;
}

																						//DONE
message GenerateAttackListResponseProto {
     required MinimumUserProto sender = 1;
     repeated FullUserProto enemies = 2;
     required GenerateAttackListStatus status = 3;
     
     enum GenerateAttackListStatus {
     	SUCCESS = 0;
     	SOME_FAIL = 1;
     	INVALID_NUM_ENEMIES_COUNT = 2;
     	INVALID_BOUND = 3;
     }
}

//------------------------------------------------------------------------------------------

																						//DONE
message RefillStatWithDiamondsRequestProto {
	required MinimumUserProto sender = 1;
	required StatType statType = 2;

	enum StatType {
		ENERGY = 0;
		STAMINA = 1;
	}
}

																						//DONE
message RefillStatWithDiamondsResponseProto {
     required MinimumUserProto sender = 1;
     required RefillStatStatus status = 2;
     
     enum RefillStatStatus {
     	SUCCESS = 0;
     	NOT_ENOUGH_DIAMONDS = 1;
     	ALREADY_MAX = 2;
     	OTHER_FAIL = 3;
     }
}

//------------------------------------------------------------------------------------------

																						//DONE
message RedeemMarketplaceEarningsRequestProto {
	required MinimumUserProto sender = 1;
}

																						//DONE
message RedeemMarketplaceEarningsResponseProto {
     required MinimumUserProto sender = 1;
     required RedeemMarketplaceEarningsStatus status = 2;
     
     enum RedeemMarketplaceEarningsStatus {
     	SUCCESS = 0;
     	OTHER_FAIL = 1;
     }
}

//------------------------------------------------------------------------------------------

																						//DONE
message LoadPlayerCityRequestProto {
	required MinimumUserProto sender = 1;
	required MinimumUserProto cityOwner = 2;
}

																						//DONE
message LoadPlayerCityResponseProto {
    required MinimumUserProto sender = 1;
    required MinimumUserProto cityOwner = 2;
	required LoadPlayerCityStatus status = 3;
	repeated FullUserStructureProto ownerNormStructs = 4;
	repeated FullUserProto ownerAllies = 5;			//only if owner is an enemy
	repeated FullUserProto ownerEnemies = 6;		//only if owner is you or ally

    optional FullUserCritstructProto armory = 7;
    optional FullUserCritstructProto vault = 8;
    optional FullUserCritstructProto marketplace = 9;
    required FullUserCritstructProto carpenter = 10;
    required FullUserCritstructProto aviary = 11;    

	optional FullUserCityExpansionDataProto userCityExpansionData = 12;
     
    enum LoadPlayerCityStatus {
     	SUCCESS = 0;
     	NO_SUCH_PLAYER = 1;
     	OTHER_FAIL = 2;
     }
}

//------------------------------------------------------------------------------------------

																						//DONE
message QuestAcceptRequestProto {
     required MinimumUserProto sender = 1;
     required int32 questId = 2;
}

																						//DONE
message QuestAcceptResponseProto {
     required MinimumUserProto sender = 1;
     required QuestAcceptStatus status = 2;

     enum QuestAcceptStatus {
          SUCCESS = 0;
          NOT_AVAIL_TO_USER = 1;
          OTHER_FAIL = 2;
     }
}

//------------------------------------------------------------------------------------------

																						//DONE
message QuestCompleteResponseProto {
     required MinimumUserProto sender = 1;
     required FullQuestProto quest = 2;
     optional NeutralCityElementProto neutralCityElement = 3;
}

//------------------------------------------------------------------------------------------

//delete all userquest data besides the one in user_quests
//client should also take away all the quests' required equips
																						//DONE
message QuestRedeemRequestProto {                         
     required MinimumUserProto sender = 1;
     required int32 questId = 2;
}

																						//DONE
message QuestRedeemResponseProto {
     required MinimumUserProto sender = 1;
     repeated FullQuestProto newlyAvailableQuests = 2;
     required QuestRedeemStatus status = 3;    

     enum QuestRedeemStatus {
          SUCCESS = 0;
          NOT_COMPLETE = 1;
          OTHER_FAIL = 2;
     }
}


//------------------------------------------------------------------------------------------

//if no questId supplied, returns userquestdetails for all in progress quests
message UserQuestDetailsRequestProto {
     required MinimumUserProto sender = 1;
     optional int32 questId = 2;
}

message UserQuestDetailsResponseProto {
     required MinimumUserProto sender = 1;
     repeated FullUserQuestDataLargeProto inProgressUserQuestData = 2;

    required UserQuestDetailsStatus status = 3;    

     enum UserQuestDetailsStatus {
          SUCCESS = 0;
          SUPPLIED_QUESTID_CURRENTLY_NOT_IN_PROGRESS = 1;
          SOME_FAIL = 2;
     }
}

//------------------------------------------------------------------------------------------


//in the future, put in neutral city elems?
																						//DONE
message RetrieveStaticDataRequestProto {
    required MinimumUserProto sender = 1;
	repeated int32 structIds = 2;
	repeated int32 taskIds = 3;
	repeated int32 questIds = 4;
	repeated int32 cityIds = 5;
	repeated int32 equipIds = 6;
	repeated int32 buildStructJobIds = 7;
	repeated int32 defeatTypeJobIds = 8;
	repeated int32 possessEquipJobIds = 9;
	repeated int32 upgradeStructJobIds = 10;
	optional int32 levelForExpRequiredRequest = 11;
}

																						//DONE
message RetrieveStaticDataResponseProto {
    required MinimumUserProto sender = 1;
	repeated FullStructureProto structs = 2;
	repeated FullTaskProto tasks = 3;
	repeated FullQuestProto quests = 4;
	repeated FullCityProto cities = 5;
	repeated FullEquipProto equips = 6;
	repeated BuildStructJobProto buildStructJobs = 7;
	repeated DefeatTypeJobProto defeatTypeJobs = 8;
	repeated PossessEquipJobProto possessEquipJobs = 9;
	repeated UpgradeStructJobProto upgradeStructJobs = 10;
	optional int32 expRequiredForRequestedLevel = 11;
	
	required RetrieveStaticDataStatus status = 12;
	
	enum RetrieveStaticDataStatus {
		SUCCESS = 0;
		SOME_FAIL = 1;
	}
	
}

//------------------------------------------------------------------------------------------

																						//DONE
message PurchaseCityExpansionRequestProto {
    required MinimumUserProto sender = 1;
    required ExpansionDirection direction = 2;
    required int64 timeOfPurchase = 3;
}

																						//DONE
message PurchaseCityExpansionResponseProto {
    required MinimumUserProto sender = 1;
    required PurchaseCityExpansionStatus status = 2;
    
    enum PurchaseCityExpansionStatus {
    	SUCCESS = 0;
    	NOT_ENOUGH_COINS = 1;
    	ALREADY_EXPANDING = 2;
    	OTHER_FAIL = 3;
    	CLIENT_TOO_AHEAD_OF_SERVER_TIME = 4;
    }
}

//------------------------------------------------------------------------------------------

																						//DONE
message ExpansionWaitCompleteRequestProto {
	required MinimumUserProto sender = 1;
	required int64 curTime = 2;						//used for checking
}

																						//DONE
message ExpansionWaitCompleteResponseProto {
     required MinimumUserProto sender = 1;
     required ExpansionWaitCompleteStatus status = 2;
     
     enum ExpansionWaitCompleteStatus {
     	SUCCESS = 0;
     	WAS_NOT_EXPANDING = 1;
     	NOT_DONE_YET = 2;
     	OTHER_FAIL = 3;
     	CLIENT_TOO_AHEAD_OF_SERVER_TIME = 4;
     }
}

//------------------------------------------------------------------------------------------

																						//DONE
message RefillStatWaitCompleteRequestProto {
	required MinimumUserProto sender = 1;
	required int64 curTime = 2;
	required RefillStatWaitCompleteType type = 3;
	
	enum RefillStatWaitCompleteType { 
		ENERGY = 0;
		STAMINA = 1;
	}
}

																						//DONE
message RefillStatWaitCompleteResponseProto {
     required MinimumUserProto sender = 1;
     required RefillStatWaitCompleteStatus status = 2;
     
     enum RefillStatWaitCompleteStatus {
     	SUCCESS = 0;
     	NOT_READY_YET = 1;
     	ALREADY_MAX = 2;
     	OTHER_FAIL = 3;
     	CLIENT_TOO_AHEAD_OF_SERVER_TIME = 4;
     }
}

//------------------------------------------------------------------------------------------

																						//DONE
message EnableAPNSRequestProto {
	required MinimumUserProto sender = 1;
	required string deviceToken = 2;
}

																						//DONE
message EnableAPNSResponseProto {
	required MinimumUserProto sender = 1;
	required EnableAPNSStatus status = 2;
	
	enum EnableAPNSStatus {
		SUCCESS = 0;
		NOT_ENABLED = 1;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message PurchaseMarketplaceLicenseRequestProto {
	required MinimumUserProto sender = 1;
	required int64 clientTime = 2;
	required LicenseType licenseType = 3;
	
	enum LicenseType {
		SHORT = 0;
		LONG = 1;
	}
}

																						//DONE
message PurchaseMarketplaceLicenseResponseProto {
	required MinimumUserProto sender = 1;
	required PurchaseMarketplaceLicenseStatus status = 2;
	
	enum PurchaseMarketplaceLicenseStatus {
		SUCCESS = 0;
		NOT_ENOUGH_DIAMONDS = 1;
		ALREADY_HAVE_LICENSE_NOW = 2;
		OTHER_FAIL = 3;
		CLIENT_TOO_AHEAD_OF_SERVER_TIME = 4;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message ReferralCodeUsedResponseProto {
	required MinimumUserProto sender = 1;
	required MinimumUserProto referredPlayer = 2;
}

//------------------------------------------------------------------------------------------

																						//DONE
message EquipEquipmentRequestProto {
	required MinimumUserProto sender = 1;
	required int32 equipId = 2;
}

																						//DONE
message EquipEquipmentResponseProto {
	required MinimumUserProto sender = 1;
	required EquipEquipmentStatus status = 2;
	
	enum EquipEquipmentStatus {
		SUCCESS = 0;
		NOT_HIGH_ENOUGH_LEVEL = 1;
		DOES_NOT_HAVE_THIS_EQUIP = 2;
		NOT_AN_EQUIP = 3;
		INCORRECT_CLASS_TYPE = 4;
		OTHER_FAIL = 5;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message ChangeUserLocationRequestProto {
     required MinimumUserProto sender = 1;
     required LocationProto userLocation = 2;    
}

																						//DONE
message ChangeUserLocationResponseProto {
     required MinimumUserProto sender = 1;
     required ChangeUserLocationStatus status = 2;
     
     enum ChangeUserLocationStatus {
     	SUCCESS = 0;
     	INVALID_BOUNDS = 1;
     	OTHER_FAIL = 2;
     }    
}

//------------------------------------------------------------------------------------------

																						//DONE
message LoadNeutralCityRequestProto {
     required MinimumUserProto sender = 1;
     required int32 cityId = 2;    
}

																						//DONE
message LoadNeutralCityResponseProto {
     required MinimumUserProto sender = 1;
     required LoadNeutralCityStatus status = 2;
     repeated MinimumUserTaskProto userTasksInfo = 3;
	     //client shouldnt show bars if already at max city level
     repeated FullUserProto defeatTypeJobEnemies = 4;
     repeated NeutralCityElementProto cityElements = 5;
     required int32 cityId = 6;
     
     enum LoadNeutralCityStatus {
     	SUCCESS = 0;
     	NOT_ACCESSIBLE_TO_USER = 1;
     	OTHER_FAIL = 2;
     }    
}

//------------------------------------------------------------------------------------------

																						//DONE
message RetrieveUserEquipForUserRequestProto {
     required MinimumUserProto sender = 1;
     required int32 relevantUserId = 2;
}

																						//DONE
message RetrieveUserEquipForUserResponseProto {
    required MinimumUserProto sender = 1;
    required int32 relevantUserId = 2;
	repeated FullUserEquipProto userEquips = 3;
}