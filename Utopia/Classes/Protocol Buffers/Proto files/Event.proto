//ALL REQUEST PROTOS SHOULD INCLUDE A MinimumUserProto AS REQUIRED that represents which client sent it/triggered it 

import "Info.proto";

package com.lvl6.proto;

option java_outer_classname = "EventProto";

//------------------------------------------------------------------------------------------

																						//DONE
message ChatRequestProto {
    optional MinimumUserProto sender = 1; 
	repeated MinimumUserProto recipients = 2;
	optional string message = 3;
}

																						//DONE
message ChatResponseProto {
    optional MinimumUserProto sender = 1; 
	optional string message = 2;
}

//------------------------------------------------------------------------------------------

																						//DONE
message BattleRequestProto {
    optional MinimumUserProto attacker = 1; 
    optional MinimumUserProto defender = 2; 
    optional BattleResult battleResult = 3;
    optional int64 clientTime = 4;
    optional int32 neutralCityId = 5;
    repeated FullUserEquipProto defenderUserEquips = 6;
}

																						//DONE
message BattleResponseProto {
    optional MinimumUserProto attacker = 1;
    optional MinimumUserProto defender = 2;
	optional BattleStatus status = 3;
	optional BattleResult battleResult = 7;

	optional int32 coinsGained = 4;
	optional FullEquipProto equipGained = 5;
    optional int32 expGained = 6;
    
    enum BattleStatus {
		SUCCESS = 0;
		OTHER_FAIL = 1;
	} 
}

//------------------------------------------------------------------------------------------

																						//DONE
message VaultRequestProto {
	optional MinimumUserProto sender = 1;
	optional VaultRequestType requestType = 2;
	optional int32 amount = 3;
	enum VaultRequestType {
		DEPOSIT = 0; 
		WITHDRAW = 1;
	} 
}

																						//DONE
message VaultResponseProto {
	optional MinimumUserProto sender = 1;
	optional VaultStatus status = 2;	
	optional int32 vaultAmount = 3;
	optional int32 coinAmount = 4;
	
	enum VaultStatus {
		SUCCESS = 0;
		OTHER_FAIL = 2;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message ArmoryRequestProto {
   enum ArmoryRequestType {
		BUY = 0; 
		SELL = 1;
	} 
	optional MinimumUserProto sender = 1;
	optional ArmoryRequestType requestType = 2;
	optional int32 quantity = 3;
	optional int32 equipId = 4;	
}

																						//DONE
message ArmoryResponseProto {
	optional MinimumUserProto sender = 1;
	optional ArmoryStatus status = 2;
	
	enum ArmoryStatus {
		SUCCESS = 0; 
		NOT_ENOUGH_EQUIP_TO_SELL = 1;
		NOT_ENOUGH_CURRENCY_TO_BUY = 2;
		CANNOT_SELL_DIAMOND_EQUIP = 3;
		OTHER_FAIL = 5;
	} 
}

//------------------------------------------------------------------------------------------

message StartupRequestProto {				//client will also send ChangeUserLocationRequestProto
     optional string udid = 1;
     optional float versionNum = 2;			//1.0->2.0 critical, 1.0->1.1 minor. server checks db for latest vnum
     optional string apsalarId = 3;
}

message StartupResponseProto {
    optional FullUserProto sender = 1;
    optional StartupStatus startupStatus= 2;
    optional UpdateStatus updateStatus= 3;
    optional StartupConstants startupConstants = 4;
    optional TutorialConstants tutorialConstants = 18;
    repeated FullCityProto allCities = 5;
    repeated FullUserCityProto userCityInfos = 16;
    
    repeated FullQuestProto inProgressIncompleteQuests = 6;
    repeated FullQuestProto inProgressCompleteQuests = 20;
	repeated FullQuestProto availableQuests = 7;   
	repeated FullUserEquipProto userEquips = 8;
    repeated FullEquipProto equips = 9;
	optional int32 experienceRequiredForNextLevel = 10;
	optional int32 experienceRequiredForCurrentLevel = 15;
	
	repeated MarketplacePostPurchasedNotificationProto marketplacePurchaseNotifications = 12;
	repeated AttackedNotificationProto attackNotifications = 13;
	repeated ReferralNotificationProto referralNotifications = 14;
	repeated PlayerWallPostProto playerWallPostNotifications = 19;
	
	optional string appStoreURL = 17;

	message MarketplacePostPurchasedNotificationProto {
		optional FullMarketplacePostProto marketplacePost = 1;
		optional MinimumUserProto buyer = 2;
		optional int64 timeOfPurchase = 3;
	}

	message AttackedNotificationProto {
		optional MinimumUserProto attacker = 1;
		optional BattleResult battleResult = 2;
		optional int64 battleCompleteTime = 3;
		optional int32 coinsStolen = 4;
		optional int32 stolenEquipId = 5;
	}
	
	message ReferralNotificationProto {
		optional MinimumUserProto referred = 1;
		optional int64 recruitTime = 2;
		optional int32 coinsGivenToReferrer = 3;
	}
		  
	message StartupConstants {
	  	repeated string productIds = 1;
	  	repeated int32 productDiamondsGiven = 2;
    	optional int32 maxLevelDifferenceForBattle = 6;
    	
    	optional int32 armoryXLength = 7;
    	optional int32 armoryYLength = 8;
    	optional int32 vaultXLength = 9;
    	optional int32 vaultYLength = 10;
    	optional int32 marketplaceXLength = 11;
    	optional int32 marketplaceYLength = 12;
    	optional int32 carpenterXLength = 13;
    	optional int32 carpenterYLength = 14;
    	optional int32 aviaryXLength = 15;
    	optional int32 aviaryYLength = 16;    	

		optional int32 attackBaseGain = 17;
		optional int32 defenseBaseGain = 18;
		optional int32 energyBaseGain = 19;
		optional int32 healthBaseGain = 20;
		optional int32 staminaBaseGain = 21;
		optional int32 attackBaseCost = 22;
		optional int32 defenseBaseCost = 23;
		optional int32 energyBaseCost = 24;
		optional int32 healthBaseCost = 25;
		optional int32 staminaBaseCost = 26;
		
		optional int32 skillPointsGainedOnLevelup = 27;
		optional double cutOfVaultDepositTaken = 28;
		
		optional int32 maxLevelForStruct = 33;
		optional int32 maxNumOfSingleStruct = 34;
		optional double percentReturnedToUserForSellingNormStructure = 35;
		
		optional int32 minutesToRefillAEnergy = 36;
		optional int32 minutesToRefillAStamina = 37;
		
		optional int32 diamondCostForFullStaminaRefill = 48;
		optional int32 diamondCostForFullEnergyRefill = 49;
		
		optional int32 maxNumberOfMarketplacePosts = 40;
		optional double percentOfSellingCostTakenFromSellerOnMarketplacePurchase = 41;
   		optional double percentOfSellingCostTakenFromSellerOnMarketplaceRetract = 42;
		optional int32 numDaysLongMarketplaceLicenseLastsFor = 43;
		optional int32 numDaysShortMarketplaceLicenseLastsFor = 44;
		optional int32 diamondCostOfLongMarketplaceLicense = 45;
		optional int32 diamondCostOfShortMarketplaceLicense = 46;

		optional int32 maxNumbersOfEnemiesToGenerateAtOnce = 4;
		optional double percentReturnedToUserForSellingEquipInArmory = 5;
		
		optional int32 maxCityRank = 50;
		
		optional int32 armoryImgVerticalPixelOffset = 54;
		optional int32 vaultImgVerticalPixelOffset = 55;
		optional int32 marketplaceImgVerticalPixelOffset = 56;
		optional int32 carpenterImgVerticalPixelOffset = 57;
		optional int32 aviaryImgVerticalPixelOffset = 58;
		
		optional FormulaConstants formulaConstants = 59;
		optional BattleConstants battleConstants = 51;

		optional int32 maxCharLengthForWallPost = 52;
		optional int32 playerWallPostsRetrieveCap = 53;
		
		message FormulaConstants {
			optional double minutesToUpgradeForNormStructMultiplier = 1;
			optional double incomeFromNormStructMultiplier = 2;
			optional double upgradeStructCoinCostExponentBase = 3;
			optional double upgradeStructDiamondCostExponentBase = 4;
			optional double diamondCostForInstantUpgradeMultiplier = 5;
			
			optional double battleWeightGivenToAttackStat = 6;
			optional double battleWeightGivenToAttackEquipSum = 7;
			optional double battleWeightGivenToDefenseStat = 8;
			optional double battleWeightGivenToDefenseEquipSum = 9;
		}
		
		message BattleConstants {
			optional float locationBarMax = 3;
			optional double maxAttackMultiplier = 4;
			optional double minPercentOfEnemyHealth = 5;
			optional double maxPercentOfEnemyHealth = 6;
			optional double battleDifferenceMultiplier = 7;
			optional double battleDifferenceTuner = 8;			
		}

	}
	
	message TutorialConstants {
		optional int32 initEnergy = 1;
		optional int32 initStamina = 2;
		optional int32 initHealth = 3;
		optional FullTutorialQuestProto tutorialQuest = 4;
		optional int32 structToBuild = 5;
		optional int32 diamondCostToInstabuildFirstStruct = 6;

		optional int32 archerInitAttack = 17;
		optional int32 archerInitDefense = 18;
		optional FullEquipProto archerInitWeapon = 7;
		optional FullEquipProto archerInitArmor = 8;
		
		optional int32 mageInitAttack = 9;
		optional int32 mageInitDefense = 10;
		optional FullEquipProto mageInitWeapon = 11;
		optional FullEquipProto mageInitArmor = 12;
		
		optional int32 warriorInitAttack = 13;
		optional int32 warriorInitDefense = 14;
		optional FullEquipProto warriorInitWeapon = 15;
		optional FullEquipProto warriorInitArmor = 16;
		
		optional int32 minNameLength = 19;
		optional int32 maxNameLength = 20;

		optional int32 coinRewardForBeingReferred = 22;		

     	repeated NeutralCityElementProto firstCityElementsForGood = 23;
     	repeated NeutralCityElementProto firstCityElementsForBad = 24;
     	optional int32 initCoins = 25;
     	optional int32 initDiamonds = 26;
     	
		repeated FullStructureProto carpenterStructs = 27;

		optional int32 expRequiredForLevelTwo = 28;
     	optional int32 expRequiredForLevelThree = 29;
     	repeated FullCityProto citiesNewlyAvailableToUserAfterLevelup = 30;					//only new ones
     	repeated FullEquipProto newlyEquippableEpicsAndLegendariesForAllClassesAfterLevelup = 31;			//only new ones
	    repeated FullStructureProto newlyAvailableStructsAfterLevelup = 32;					//only new ones
     	
		message FullTutorialQuestProto {
				//do one task once, kill one enemy
			optional string goodName = 1;
			optional string badName = 2;
			optional string goodDescription = 3;
			optional string badDescription = 4;
			optional string goodDoneResponse = 5;
			optional string badDoneResponse = 6;
			optional DialogueProto goodAcceptDialogue = 7;
			optional DialogueProto badAcceptDialogue = 8;
			optional int32 assetNumWithinCity = 9; 
			optional int32 coinsGained = 10;
			optional int32 expGained = 11;
			
			optional FullTaskProto firstTaskGood = 12;
			optional FullTaskProto firstTaskBad = 13;
			optional int32 firstTaskCompleteCoinGain = 14;	//tasks coin gain should sum to this

			optional int32 firstDefeatTypeJobBattleCoinGain = 17;
			optional int32 firstDefeatTypeJobBattleExpGain = 18;
			optional FullEquipProto firstDefeatTypeJobBattleLootAmulet = 19;
		}
	}
		     
    enum UpdateStatus {
     	NO_UPDATE = 0;
     	MINOR_UPDATE = 1;			//NOTIFY USER OF NEW FEATURES AND/OR ASK USER IF HE WANTS TO UPDATE NOW
     	MAJOR_UPDATE = 2;			//NOT ALLOWED TO PLAY
     }
     
	enum StartupStatus {
		USER_IN_DB = 0; 
		USER_NOT_IN_DB = 1;
	}    
}

//------------------------------------------------------------------------------------------
//CALL STARTUP AFTER THIS

//if devicetoken doesnt work, itll still return success
//client can check user's diamonds to see if it went through
message UserCreateRequestProto {
     optional string udid = 1;
     optional string name = 2;
     optional UserType type = 3;
     optional LocationProto userLocation = 6;     
     optional string referrerCode = 7;
     optional string deviceToken = 8;
     optional int32 attack = 9;
     optional int32 defense = 10;
     optional int32 health = 11;
     optional int32 energy = 12;
     optional int32 stamina = 13;
     
     optional int64 timeOfStructPurchase = 14;
     optional int64 timeOfStructBuild = 15;
     optional CoordinateProto structCoords = 4;
     optional bool usedDiamondsToBuilt = 16;
}

message UserCreateResponseProto {
	optional FullUserProto sender = 1;
	optional UserCreateStatus status = 2;
	
    enum UserCreateStatus {
		SUCCESS = 0;
		INVALID_NAME = 1;
		INVALID_LOCATION = 2;
		USER_WITH_UDID_ALREADY_EXISTS = 3;
     	TIME_ISSUE = 4;
     	INVALID_SKILL_POINT_ALLOCATION = 5;
     	INVALID_REFER_CODE = 6;
		OTHER_FAIL = 7;
	}  
}

//------------------------------------------------------------------------------------------

																						//DONE
message RetrieveTasksForCityRequestProto {
     optional MinimumUserProto sender = 1;
     optional int32 cityId = 2;
}

																						//DONE
message RetrieveTasksForCityResponseProto {
     optional MinimumUserProto sender = 1;
     repeated FullTaskProto tasks = 2;
}

//------------------------------------------------------------------------------------------

																						//DONE
message RetrieveStaticDataForShopRequestProto {
     optional MinimumUserProto sender = 1;
	optional RetrieveForShopType type = 2;
		
	enum RetrieveForShopType {
		EQUIPMENT_FOR_ARMORY = 0;
		ALL_STRUCTURES = 1;
	}
}
																						//DONE
message RetrieveStaticDataForShopResponseProto {
     optional MinimumUserProto sender = 1;
     optional RetrieveStaticDataForShopStatus status = 2;
     repeated FullEquipProto equips = 3;
     repeated FullStructureProto structs = 4;
     
     enum RetrieveStaticDataForShopStatus {
     	SUCCESS = 0;
     	SOME_FAIL = 1;
     }
}

//------------------------------------------------------------------------------------------

																						//DONE
message TaskActionRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 taskId = 2;
	optional int64 curTime = 3;
}

																						//DONE
message TaskActionResponseProto {
	optional MinimumUserProto sender = 1;
	optional TaskActionStatus status = 2;
	optional bool taskCompleted = 3;
	optional bool cityRankedUp = 4;
	optional int32 lootEquipId = 5;
	optional int32 coinsGained = 6;
	
	optional int32 coinBonusIfCityRankup = 7;
	optional int32 expBonusIfCityRankup = 8;
	optional int32 cityId = 9;
	
	enum TaskActionStatus {
		SUCCESS = 0; 
		USER_NOT_ENOUGH_ENERGY = 1;
		USER_NOT_ALL_REQUIRED_ITEMS = 2;
		OTHER_FAIL = 3;
		CLIENT_TOO_APART_FROM_SERVER_TIME = 4;
	} 
}

//------------------------------------------------------------------------------------------

																						//DONE
message PurchaseNormStructureRequestProto {
	optional MinimumUserProto sender = 1;
	optional CoordinateProto structCoordinates = 2;
	optional int32 structId = 3;
	optional int64 timeOfPurchase = 4;
}

																						//DONE
message PurchaseNormStructureResponseProto {
	optional MinimumUserProto sender = 1;
	optional PurchaseNormStructureStatus status = 2;
	optional int32 userStructId = 3;
	
	enum PurchaseNormStructureStatus {
		SUCCESS = 0;
		NOT_ENOUGH_MATERIALS = 1;
		LEVEL_TOO_LOW = 2;
		ANOTHER_STRUCT_STILL_BUILDING = 3;
		ALREADY_HAVE_MAX_OF_THIS_STRUCT = 4;
		OTHER_FAIL = 5;
		CLIENT_TOO_APART_FROM_SERVER_TIME = 6;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message MoveOrRotateNormStructureRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 userStructId = 2;
	optional MoveOrRotateNormStructType type = 3;
	optional CoordinateProto curStructCoordinates = 4;
	optional StructOrientation newOrientation = 5;
	
	enum MoveOrRotateNormStructType {
		MOVE = 0;
		ROTATE = 1;
	}
}

																						//DONE
message MoveOrRotateNormStructureResponseProto {
	optional MinimumUserProto sender = 1;
	optional MoveOrRotateNormStructureStatus status = 2;
	
	enum MoveOrRotateNormStructureStatus {
		SUCCESS = 0;
		OTHER_FAIL = 2;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message SellNormStructureRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 userStructId = 2;
}

																						//DONE
message SellNormStructureResponseProto {
	optional MinimumUserProto sender = 1;
	optional SellNormStructureStatus status = 2;
	
	enum SellNormStructureStatus {
		SUCCESS = 0;
		FAIL = 1;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message UpgradeNormStructureRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 userStructId = 2;
	optional int64 timeOfUpgrade = 3;	
}

																						//DONE
message UpgradeNormStructureResponseProto {
	optional MinimumUserProto sender = 1;
	optional UpgradeNormStructureStatus status = 2;
	
	enum UpgradeNormStructureStatus {
		SUCCESS = 0;
		NOT_ENOUGH_MATERIALS = 1;
		NOT_BUILT_YET = 2;
		NOT_USERS_STRUCT = 3;
		ANOTHER_STRUCT_STILL_UPGRADING = 4;
		OTHER_FAIL = 5;
		CLIENT_TOO_APART_FROM_SERVER_TIME = 6;
		AT_MAX_LEVEL_ALREADY = 7;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message RetrieveCurrencyFromNormStructureRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 userStructId = 2;
	optional int64 timeOfRetrieval = 3;	
}

																						//DONE
message RetrieveCurrencyFromNormStructureResponseProto {
	optional MinimumUserProto sender = 1;
	optional RetrieveCurrencyFromNormStructureStatus status = 2;
	
	enum RetrieveCurrencyFromNormStructureStatus {
		SUCCESS = 0;
		NOT_LONG_ENOUGH = 1;
		OTHER_FAIL = 2;
		CLIENT_TOO_APART_FROM_SERVER_TIME = 3;
		LEVEL_TOO_LOW = 4;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message CriticalStructureActionRequestProto {
	optional MinimumUserProto sender = 1;
	optional CritStructActionType actionType = 2;
	optional CritStructType critStructType = 3;
	optional CoordinateProto critStructCoordinates = 4;
	optional StructOrientation orientation = 5;
	
	enum CritStructActionType {
		PLACE = 0;
		MOVE = 1;
		ROTATE = 2;
	}
}

																						//DONE
message CriticalStructureActionResponseProto {
	optional MinimumUserProto sender = 1;
	optional CritStructActionStatus status = 3;
	
	enum CritStructActionStatus {
		SUCCESS = 0;
		CANNOT_PLACE_NON_PLACEABLE_CRIT_STRUCT = 1;	//we only place armory/vault/marketplace 
		CANNOT_MOVE_AVIARY = 3;
		OTHER_FAIL = 4;	
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message FinishNormStructWaittimeWithDiamondsRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 userStructId = 2;
	optional int64 timeOfSpeedup = 3;			//lastRetrieved will start with this date
	optional NormStructWaitTimeType waitTimeType = 4;

	enum NormStructWaitTimeType {
		FINISH_CONSTRUCTION = 0;
		FINISH_INCOME_WAITTIME = 1;
		FINISH_UPGRADE = 2;
	}
}

																						//DONE
message FinishNormStructWaittimeWithDiamondsResponseProto {
     optional MinimumUserProto sender = 1;
     optional FinishNormStructWaittimeStatus status = 2;
     
     enum FinishNormStructWaittimeStatus {
     	SUCCESS = 0;
     	NOT_ENOUGH_DIAMONDS = 1;
     	OTHER_FAIL = 2;
     	CLIENT_TOO_APART_FROM_SERVER_TIME = 3;
     }
}

//------------------------------------------------------------------------------------------

//this message sent to server after a player's homepage is loaded and client checks which structs 
//have been built but not reflected in db yet (so when is_complete=0 but the purchase_time 
//implies that it should be)
//this message is also sent whenever the player is on the screen and the build completes
//i would set last_retrieved manually to when it should have completed, and is_complete=1
											
																						//DONE
//NOT VERY EFFICIENT..extra db call. and for every newly built building, new db call. but w/e for now.																						
message NormStructWaitCompleteRequestProto {
	optional MinimumUserProto sender = 1;
	repeated int32 userStructId = 2;
	optional int64 curTime = 3;						//used for checking
}

																						//DONE
message NormStructWaitCompleteResponseProto {
     optional MinimumUserProto sender = 1;
     optional NormStructWaitCompleteStatus status = 2;
     repeated FullUserStructureProto userStruct = 3;
     
     enum NormStructWaitCompleteStatus {
     	SUCCESS = 0;
     	NOT_DONE_YET = 1;
     	OTHER_FAIL = 2;
     	CLIENT_TOO_APART_FROM_SERVER_TIME = 3;
     }
}

//------------------------------------------------------------------------------------------

//client calls this whenever exp surpasses the next one
//server checks if user's exp is over the next, if so, increments user's level
																						//DONE

message LevelUpRequestProto {
	optional MinimumUserProto sender = 1;
}

																						//DONE
message LevelUpResponseProto {
     optional MinimumUserProto sender = 1;
     optional LevelUpStatus status = 2;
     
     optional int32 newLevel = 11;
     optional int32 newNextLevel = 3;
     optional int32 experienceRequiredForNewNextLevel = 4;
	 repeated FullCityProto citiesNewlyAvailableToUser = 5;					//only new ones
     repeated FullEquipProto newlyEquippableEpicsAndLegendaries = 6;			//only new ones
     repeated FullStructureProto newlyAvailableStructs = 7;					//only new ones

	enum LevelUpStatus {
     	SUCCESS = 0;
     	NOT_ENOUGH_EXP_TO_NEXT_LEVEL = 1;
     	ALREADY_AT_MAX_LEVEL = 2;
     	OTHER_FAIL = 3;
     }
}

//------------------------------------------------------------------------------------------

																						//DONE
message InAppPurchaseRequestProto {
	optional MinimumUserProto sender = 1;
	optional string receipt = 2;
}

																						//DONE
message InAppPurchaseResponseProto {
	optional MinimumUserProto sender = 1;
	optional InAppPurchaseStatus status = 2;
	optional int32 diamondsGained = 3;
	
	enum InAppPurchaseStatus {
		SUCCESS = 0;
		FAIL = 1;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message UpdateClientUserResponseProto {
     optional FullUserProto sender = 1;
     optional int64 timeOfUserUpdate = 2;				//new Date().getTime(); milliseconds since 1/1/70
}

//------------------------------------------------------------------------------------------

message RetrieveCurrentMarketplacePostsRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 beforeThisPostId = 2;
	optional bool fromSender = 3;
}

																						//DONE
message RetrieveCurrentMarketplacePostsResponseProto {
     optional MinimumUserProto sender = 1;
     optional bool fromSender = 2;
     optional int32 beforeThisPostId = 3;
	 optional RetrieveCurrentMarketplacePostsStatus status = 4;
     
     repeated FullMarketplacePostProto marketplacePosts = 5;
     
     enum RetrieveCurrentMarketplacePostsStatus {
     	SUCCESS = 0;
     	OTHER_FAIL = 2;
     }
}

//------------------------------------------------------------------------------------------

																						//DONE
message PostToMarketplaceRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 postedEquipId = 2;
	optional int32 diamondCost = 3;
	optional int32 coinCost = 4;
}

																						//DONE
message PostToMarketplaceResponseProto {
     optional MinimumUserProto sender = 1;
     optional PostToMarketplaceStatus status = 2;
    
    enum PostToMarketplaceStatus {
		SUCCESS = 0;
		NEGATIVE_POST = 1;
		NOT_ENOUGH_EQUIP = 2;
		NEGATIVE_COST = 3;
		NO_COST = 4;
		USER_ALREADY_MAX_MARKETPLACE_POSTS = 5;
		CANT_DEMAND_BOTH = 6;
		INVALID_COST_TYPE_FOR_POST = 7;
		OTHER_FAIL = 8;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message RetractMarketplacePostRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 marketplacePostId = 2;
}

																						//DONE
message RetractMarketplacePostResponseProto {
     optional MinimumUserProto sender = 1;
     optional RetractMarketplacePostStatus status = 2;

	enum RetractMarketplacePostStatus {
		SUCCESS = 0;
		NOT_REQUESTERS_POST = 1;
		POST_NO_LONGER_EXISTS = 2;
		NOT_ENOUGH_DIAMONDS = 3;
		NOT_ENOUGH_COINS = 4;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message PurchaseFromMarketplaceRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 marketplacePostId = 2;
	optional int32 posterId = 3;
}

																						//DONE
message PurchaseFromMarketplaceResponseProto {
     optional MinimumUserProto purchaser = 1;
     optional int32 posterId = 2;
     optional FullMarketplacePostProto marketplacePost = 3;
     
     optional PurchaseFromMarketplaceStatus status = 4;

	enum PurchaseFromMarketplaceStatus {
		SUCCESS = 0;
		NOT_ENOUGH_MATERIALS = 1;
		POST_NO_LONGER_EXISTS = 2;
		PURCHASER_IS_SELLER = 3;
		OTHER_FAIL = 5;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message UseSkillPointRequestProto {
	optional MinimumUserProto sender = 1;
	optional BoostType boostType = 2;
	
	enum BoostType {
		ATTACK = 0;
		DEFENSE = 1;
		ENERGY = 2;
		HEALTH = 3;
		STAMINA = 4;
	}
}

																						//DONE
message UseSkillPointResponseProto {
     optional MinimumUserProto sender = 1;
     optional UseSkillPointStatus status = 2;
     
     enum UseSkillPointStatus {
		SUCCESS = 0;
		NOT_ENOUGH_SKILL_POINTS = 1;
		OTHER_FAIL = 2;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message GenerateAttackListRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 numEnemies = 2;
	optional double latLowerBound = 3;
	optional double latUpperBound = 4;
	optional double longLowerBound = 5;
	optional double longUpperBound = 6;
}

																						//DONE
message GenerateAttackListResponseProto {
     optional MinimumUserProto sender = 1;
     repeated FullUserProto enemies = 2;
     optional GenerateAttackListStatus status = 3;
     
     enum GenerateAttackListStatus {
     	SUCCESS = 0;
     	SOME_FAIL = 1;
     	INVALID_NUM_ENEMIES_COUNT = 2;
     	INVALID_BOUND = 3;
     }
}

//------------------------------------------------------------------------------------------

																						//DONE
message RefillStatWithDiamondsRequestProto {
	optional MinimumUserProto sender = 1;
	optional StatType statType = 2;

	enum StatType {
		ENERGY = 0;
		STAMINA = 1;
	}
}

																						//DONE
message RefillStatWithDiamondsResponseProto {
     optional MinimumUserProto sender = 1;
     optional RefillStatStatus status = 2;
     
     enum RefillStatStatus {
     	SUCCESS = 0;
     	NOT_ENOUGH_DIAMONDS = 1;
     	ALREADY_MAX = 2;
     	OTHER_FAIL = 3;
     }
}

//------------------------------------------------------------------------------------------

																						//DONE
message RedeemMarketplaceEarningsRequestProto {
	optional MinimumUserProto sender = 1;
}

																						//DONE
message RedeemMarketplaceEarningsResponseProto {
     optional MinimumUserProto sender = 1;
     optional RedeemMarketplaceEarningsStatus status = 2;
     
     enum RedeemMarketplaceEarningsStatus {
     	SUCCESS = 0;
     	OTHER_FAIL = 1;
     }
}

//------------------------------------------------------------------------------------------

																						//DONE
message LoadPlayerCityRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 cityOwnerId = 2;
}

																						//DONE
message LoadPlayerCityResponseProto {
    optional MinimumUserProto sender = 1;
    optional MinimumUserProto cityOwner = 2;
	optional LoadPlayerCityStatus status = 3;
	repeated FullUserStructureProto ownerNormStructs = 4;
	repeated FullUserProto ownerAllies = 5;			//only if owner is an enemy
	repeated FullUserProto ownerEnemies = 6;		//only if owner is you or ally

    optional FullUserCritstructProto armory = 7;
    optional FullUserCritstructProto vault = 8;
    optional FullUserCritstructProto marketplace = 9;
    optional FullUserCritstructProto carpenter = 10;
    optional FullUserCritstructProto aviary = 11;    

	optional FullUserCityExpansionDataProto userCityExpansionData = 12;
     
    enum LoadPlayerCityStatus {
     	SUCCESS = 0;
     	NO_SUCH_PLAYER = 1;
     	OTHER_FAIL = 2;
     }
}

//------------------------------------------------------------------------------------------

																						//DONE
message QuestAcceptRequestProto {
     optional MinimumUserProto sender = 1;
     optional int32 questId = 2;
}

																						//DONE
message QuestAcceptResponseProto {
     optional MinimumUserProto sender = 1;
     optional QuestAcceptStatus status = 2;
     optional int32 cityIdOfAcceptedQuest = 4;

     enum QuestAcceptStatus {
          SUCCESS = 0;
          NOT_AVAIL_TO_USER = 1;
          OTHER_FAIL = 2;
     }
}

//------------------------------------------------------------------------------------------

																						//DONE
message QuestCompleteResponseProto {
     optional MinimumUserProto sender = 1;
     optional int32 questId = 2;
     optional NeutralCityElementProto neutralCityElement = 3;
}

//------------------------------------------------------------------------------------------

//delete all userquest data besides the one in user_quests
//client should also take away all the quests' requiredequips
																						//DONE
message QuestRedeemRequestProto {                         
     optional MinimumUserProto sender = 1;
     optional int32 questId = 2;
}

																						//DONE
message QuestRedeemResponseProto {
     optional MinimumUserProto sender = 1;
     repeated FullQuestProto newlyAvailableQuests = 2;
     optional QuestRedeemStatus status = 3;    

     enum QuestRedeemStatus {
          SUCCESS = 0;
          NOT_COMPLETE = 1;
          OTHER_FAIL = 2;
     }
}


//------------------------------------------------------------------------------------------

//if no questId supplied, returns userquestdetails for all in progress quests
message UserQuestDetailsRequestProto {
     optional MinimumUserProto sender = 1;
     optional int32 questId = 2;
}

message UserQuestDetailsResponseProto {
     optional MinimumUserProto sender = 1;
     repeated FullUserQuestDataLargeProto inProgressUserQuestData = 2;

    optional UserQuestDetailsStatus status = 3;    

     enum UserQuestDetailsStatus {
          SUCCESS = 0;
          SUPPLIED_QUESTID_CURRENTLY_NOT_IN_PROGRESS = 1;
          SOME_FAIL = 2;
     }
}

//------------------------------------------------------------------------------------------


//in the future, put in neutral city elems?
																						//DONE
message RetrieveStaticDataRequestProto {
    optional MinimumUserProto sender = 1;
	repeated int32 structIds = 2;
	repeated int32 taskIds = 3;
	repeated int32 questIds = 4;
	repeated int32 cityIds = 5;
	repeated int32 equipIds = 6;
	repeated int32 buildStructJobIds = 7;
	repeated int32 defeatTypeJobIds = 8;
	repeated int32 possessEquipJobIds = 9;
	repeated int32 upgradeStructJobIds = 10;
	optional int32 levelForExpRequiredRequest = 11;
}

																						//DONE
message RetrieveStaticDataResponseProto {
    optional MinimumUserProto sender = 1;
	repeated FullStructureProto structs = 2;
	repeated FullTaskProto tasks = 3;
	repeated FullQuestProto quests = 4;
	repeated FullCityProto cities = 5;
	repeated FullEquipProto equips = 6;
	repeated BuildStructJobProto buildStructJobs = 7;
	repeated DefeatTypeJobProto defeatTypeJobs = 8;
	repeated PossessEquipJobProto possessEquipJobs = 9;
	repeated UpgradeStructJobProto upgradeStructJobs = 10;
	optional int32 expRequiredForRequestedLevel = 11;
	
	optional RetrieveStaticDataStatus status = 12;
	
	enum RetrieveStaticDataStatus {
		SUCCESS = 0;
		SOME_FAIL = 1;
	}
	
}

//------------------------------------------------------------------------------------------

																						//DONE
message PurchaseCityExpansionRequestProto {
    optional MinimumUserProto sender = 1;
    optional ExpansionDirection direction = 2;
    optional int64 timeOfPurchase = 3;
}

																						//DONE
message PurchaseCityExpansionResponseProto {
    optional MinimumUserProto sender = 1;
    optional PurchaseCityExpansionStatus status = 2;
    
    enum PurchaseCityExpansionStatus {
    	SUCCESS = 0;
    	NOT_ENOUGH_COINS = 1;
    	ALREADY_EXPANDING = 2;
    	OTHER_FAIL = 3;
    	CLIENT_TOO_APART_FROM_SERVER_TIME = 4;
    }
}

//------------------------------------------------------------------------------------------

																						//DONE
message ExpansionWaitCompleteRequestProto {
	optional MinimumUserProto sender = 1;
	optional int64 curTime = 2;						//used for checking
}

																						//DONE
message ExpansionWaitCompleteResponseProto {
     optional MinimumUserProto sender = 1;
     optional ExpansionWaitCompleteStatus status = 2;
     
     enum ExpansionWaitCompleteStatus {
     	SUCCESS = 0;
     	WAS_NOT_EXPANDING = 1;
     	NOT_DONE_YET = 2;
     	OTHER_FAIL = 3;
     	CLIENT_TOO_APART_FROM_SERVER_TIME = 4;
     }
}

//------------------------------------------------------------------------------------------

																						//DONE
message RefillStatWaitCompleteRequestProto {
	optional MinimumUserProto sender = 1;
	optional int64 curTime = 2;
	optional RefillStatWaitCompleteType type = 3;
	
	enum RefillStatWaitCompleteType { 
		ENERGY = 0;
		STAMINA = 1;
	}
}

																						//DONE
message RefillStatWaitCompleteResponseProto {
     optional MinimumUserProto sender = 1;
     optional RefillStatWaitCompleteStatus status = 2;
     
     enum RefillStatWaitCompleteStatus {
     	SUCCESS = 0;
     	NOT_READY_YET = 1;
     	ALREADY_MAX = 2;
     	OTHER_FAIL = 3;
     	CLIENT_TOO_APART_FROM_SERVER_TIME = 4;
     }
}

//------------------------------------------------------------------------------------------

																						//DONE
message EnableAPNSRequestProto {
	optional MinimumUserProto sender = 1;
	optional string deviceToken = 2;
}

																						//DONE
message EnableAPNSResponseProto {
	optional MinimumUserProto sender = 1;
	optional EnableAPNSStatus status = 2;
	
	enum EnableAPNSStatus {
		SUCCESS = 0;
		NOT_ENABLED = 1;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message PurchaseMarketplaceLicenseRequestProto {
	optional MinimumUserProto sender = 1;
	optional int64 clientTime = 2;
	optional LicenseType licenseType = 3;
	
	enum LicenseType {
		SHORT = 0;
		LONG = 1;
	}
}

																						//DONE
message PurchaseMarketplaceLicenseResponseProto {
	optional MinimumUserProto sender = 1;
	optional PurchaseMarketplaceLicenseStatus status = 2;
	
	enum PurchaseMarketplaceLicenseStatus {
		SUCCESS = 0;
		NOT_ENOUGH_DIAMONDS = 1;
		ALREADY_HAVE_LICENSE_NOW = 2;
		OTHER_FAIL = 3;
		CLIENT_TOO_APART_FROM_SERVER_TIME = 4;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message ReferralCodeUsedResponseProto {
	optional MinimumUserProto sender = 1;
	optional MinimumUserProto referredPlayer = 2;
	optional int32 coinsGivenToReferrer = 3;
}

//------------------------------------------------------------------------------------------

																						//DONE
message EquipEquipmentRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 equipId = 2;
}

																						//DONE
message EquipEquipmentResponseProto {
	optional MinimumUserProto sender = 1;
	optional EquipEquipmentStatus status = 2;
	
	enum EquipEquipmentStatus {
		SUCCESS = 0;
		NOT_HIGH_ENOUGH_LEVEL = 1;
		DOES_NOT_HAVE_THIS_EQUIP = 2;
		NOT_AN_EQUIP = 3;
		INCORRECT_CLASS_TYPE = 4;
		OTHER_FAIL = 5;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message ChangeUserLocationRequestProto {
     optional MinimumUserProto sender = 1;
     optional LocationProto userLocation = 2;    
}

																						//DONE
message ChangeUserLocationResponseProto {
     optional MinimumUserProto sender = 1;
     optional ChangeUserLocationStatus status = 2;
     
     enum ChangeUserLocationStatus {
     	SUCCESS = 0;
     	INVALID_BOUNDS = 1;
     	OTHER_FAIL = 2;
     }    
}

//------------------------------------------------------------------------------------------

																						//DONE
message LoadNeutralCityRequestProto {
     optional MinimumUserProto sender = 1;
     optional int32 cityId = 2;    
}

																						//DONE
message LoadNeutralCityResponseProto {
     optional MinimumUserProto sender = 1;
     optional LoadNeutralCityStatus status = 2;
     repeated MinimumUserTaskProto userTasksInfo = 3;
	     //client shouldnt show bars if already at max city level
     repeated FullUserProto defeatTypeJobEnemies = 4;
     repeated NeutralCityElementProto cityElements = 5;
     optional int32 cityId = 6;
     repeated FullUserQuestDataLargeProto inProgressUserQuestDataInCity = 7;
     
     enum LoadNeutralCityStatus {
     	SUCCESS = 0;
     	NOT_ACCESSIBLE_TO_USER = 1;
     	OTHER_FAIL = 2;
     }    
}

//------------------------------------------------------------------------------------------

																						//DONE
message RetrieveUserEquipForUserRequestProto {
     optional MinimumUserProto sender = 1;
     optional int32 relevantUserId = 2;
}

																						//DONE
message RetrieveUserEquipForUserResponseProto {
    optional MinimumUserProto sender = 1;
    optional int32 relevantUserId = 2;
	repeated FullUserEquipProto userEquips = 3;
}

//------------------------------------------------------------------------------------------

																						//DONE
message PurgeClientStaticDataResponseProto {
     optional int32 senderId = 1;
}

//------------------------------------------------------------------------------------------

																						//DONE
message RetrieveUsersForUserIdsRequestProto {
    optional MinimumUserProto sender = 1;
	repeated int32 requestedUserIds = 2;
}

																						//DONE
message RetrieveUsersForUserIdsResponseProto {
    optional MinimumUserProto sender = 1;
	repeated FullUserProto requestedUsers = 2;
}

//------------------------------------------------------------------------------------------

																						//DONE
message PostOnPlayerWallRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 wallOwnerId = 2;
	optional string content = 3;
}

																						//DONE
message PostOnPlayerWallResponseProto {
	 optional MinimumUserProto sender = 1;
     optional PostOnPlayerWallStatus status = 2;
	 optional PlayerWallPostProto post = 3;
	
     enum PostOnPlayerWallStatus {
     	SUCCESS = 0;
     	NO_CONTENT_SENT = 1;
     	POST_TOO_LARGE = 2;
     	OTHER_FAIL = 3;
	}
}

//------------------------------------------------------------------------------------------

																						//DONE
message RetrievePlayerWallPostsRequestProto {
	optional MinimumUserProto sender = 1;
	optional int32 relevantUserId = 2;
	optional int32 beforeThisPostId = 3;
}

																						//DONE
message RetrievePlayerWallPostsResponseProto {
     optional MinimumUserProto sender = 1;
     optional int32 relevantUserId = 2;
     optional int32 beforeThisPostId = 3;
	 optional RetrievePlayerWallPostsStatus status = 4;
     
     repeated PlayerWallPostProto playerWallPosts = 5;
     
     enum RetrievePlayerWallPostsStatus {
     	SUCCESS = 0;
     	OTHER_FAIL = 1;
     }
}

//------------------------------------------------------------------------------------------

message EarnFreeDiamondsRequestProto {
	optional MinimumUserProto sender = 1;
	optional EarnFreeDiamondsType freeDiamondsType = 2;
	optional int64 clientTime = 3;
		
	optional string kiipReceipt = 4;

	optional string adColonyDigest = 5;
	optional int32 adColonyDiamondsEarned = 6;
		
	enum EarnFreeDiamondsType {
		KIIP = 1;
		ADCOLONY = 2;
		FB_INVITE = 3;
		TAPJOY = 4;
		FLURRY_VIDEO = 5;
		TWITTER = 6;
	}

}

message EarnFreeDiamondsResponseProto {
	optional MinimumUserProto sender = 1;
	optional EarnFreeDiamondsStatus status = 2;
	
	enum EarnFreeDiamondsStatus {
		SUCCESS = 0;
		CLIENT_TOO_APART_FROM_SERVER_TIME = 1;
		METHOD_NOT_SUPPORTED = 2;
		OTHER_FAIL = 3;
	}
}